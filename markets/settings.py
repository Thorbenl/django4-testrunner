"""
Django settings for markets project.

Generated by 'django-admin startproject' using Django 2.0.

For more information on this file, see
https://docs.djangoproject.com/en/2.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.0/ref/settings/
"""
import os
import sys
import warnings
from datetime import timedelta
from distutils.util import strtobool
from typing import Any, Dict, Optional, cast

import dj_database_url
from django.core.cache import CacheKeyWarning
from django.utils import timezone

from markets.market_settings.markets import *

warnings.simplefilter("ignore", CacheKeyWarning)

SITE_ID = 1

RUNNING_TESTS = sys.argv[1:2] == ['test']
RUNNING_FUNCTIONAL_TESTS = sys.argv[4:5] == ['functional']
# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

DEFAULT_AUTO_FIELD = 'django.db.models.AutoField'

MARKET: Optional[str]

if RUNNING_TESTS:
    MARKET = os.environ.get("MARKET", MARKET_A)
else:
    # If MARKET is not provided, use None as "market", which means all market-specific apps will be included.
    # This is useful when making all migrations, compiling translations, or type-checking with mypy.
    MARKET = os.environ.get("MARKET", None)


if MARKET is not None and not valid_market(MARKET):
    raise Exception("Unknown market")


TIME_ZONE = 'UTC'

if MARKET is None:
    # Just enough settings to allow migrations to be made.
    from markets.market_settings.no_market import *
elif MARKET == MARKET_B:
    from markets.market_settings.market_b import *
elif MARKET == MARKET_A:
    from markets.market_settings.market_a import *
else:
    raise Exception(f"Cannot proceed without unknown market value: {MARKET}")

SECRET_KEY = os.environ.get("SECRET_KEY", "_^5i=ol!4&9zkuj9w3iaksa^r504(tflz$e9x!o5doj%7zc6m0")
DEBUG = strtobool(os.environ.get("DEBUG", "0"))
DISABLE_PASSWORD_CHECKS = strtobool(os.environ.get("DISABLE_PASSWORD_CHECKS", "0"))
ALLOW_ROBOTS = strtobool(os.environ.get("ALLOW_ROBOTS", "0"))
ENVIRONMENT_CREATION_DATETIME = os.environ.get("ENVIRONMENT_CREATION_DATETIME", None)


DOWNLOAD_IMAGES_USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) ' \
                             'Chrome/71.0.3578.98 Safari/537.36 '

SECURE_SSL_REDIRECT = strtobool(os.environ.get("FORCE_HTTPS", "False"))

SECURE_HSTS_SECONDS = int(os.environ.get("SECURE_HSTS_SECONDS", 31536000))
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False

TEST_RUNNER = "markets.test_runner.CustomTestSuiteRunner"
IN_DORMANT_MODE = strtobool(os.environ.get("IN_DORMANT_MODE", "False"))


SITE_DOMAIN = os.environ.get("SITE_DOMAIN", "localhost")

if RUNNING_TESTS:
    BASE_URL = "https://localhost"
else:
    BASE_URL = os.environ.get("BASE_URL", f"https://{SITE_DOMAIN}")


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.0/howto/static-files/
S3_STATIC_BUCKET = os.environ.get("S3_STATIC_BUCKET")
if S3_STATIC_BUCKET:
    USE_CDN = True
else:
    USE_CDN = False

if USE_CDN:
    STATIC_URL = cast(str, os.environ.get("CDN_URL", f"https://assets.{SITE_DOMAIN}/static/"))
else:
    STATIC_URL = '/static/'

STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# CACHING

DISABLE_CACHE = strtobool(os.environ.get('DISABLE_CACHE', '0'))
if RUNNING_TESTS and not RUNNING_FUNCTIONAL_TESTS:
    DISABLE_CACHE = True

if DISABLE_CACHE and not RUNNING_FUNCTIONAL_TESTS:
    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
        }
    }
elif RUNNING_FUNCTIONAL_TESTS:
    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
            'LOCATION': 'unique-snowflake',
        }
    }
else:
    _redis_url = os.environ.get('REDIS_URL')
    if _redis_url is not None:
        CACHES = {
            "default": {
                "BACKEND": "redis_cache.RedisCache",
                "LOCATION": _redis_url,
                "KEY_PREFIX": os.environ.get('HEROKU_RELEASE_VERSION', ''),
                "OPTIONS": {  # type: ignore
                    "DB": 1
                }
            }
        }

# BEGIN CELERY SETTINGS
CELERY_PRESENT = "REDIS_URL" in os.environ

if CELERY_PRESENT:
    CELERY_TASK_ALWAYS_EAGER = False
    CELERY_BROKER_POOL_LIMIT = int(os.environ.get("CELERY_BROKER_POOL_LIMIT", "1"))
    CELERY_BROKER_HEARTBEAT: Optional[float] = None  # We're using TCP keep-alive instead
    CELERY_CONNECTION_TIMEOUT = 30  # May require a long timeout due to Linux DNS timeouts etc
    CELERY_BROKER_URL = os.environ.get("REDIS_URL")
    CELERY_RESULT_BACKEND = os.environ.get("REDIS_URL")
    CELERY_ACCEPT_CONTENT = ['json']
    CELERY_EVENT_QUEUE_EXPIRES = 60  # Will delete all celeryev. queues without consumers after 1 minute.

    if "CELERY_WORKER_MAX_MEMORY_PER_CHILD" in os.environ:
        # If a worker uses more than this amount of memory in KB, it will be replaced after the task completes
        # (to avoid leaking memory).
        CELERY_WORKER_MAX_MEMORY_PER_CHILD = int(os.environ["CELERY_WORKER_MAX_MEMORY_PER_CHILD"])
    CELERY_WORKER_SEND_TASK_EVENTS = True
    CELERY_TASK_SEND_SENT_EVENT = True
    CELERY_WORKER_PREFETCH_MULTIPLIER = int(os.environ.get("CELERY_WORKER_PREFETCH_MULTIPLIER", "1"))
    # If your tasks are CPU bound, then limit to the number of cores, otherwise increase substantially
    CELERY_WORKER_CONCURRENCY = int(os.environ.get("CELERY_WORKER_CONCURRENCY", "4"))
    CELERY_TASK_SERIALIZER = 'json'
    CELERY_RESULT_SERIALIZER = 'json'
else:
    CELERY_TASK_ALWAYS_EAGER = True
    CELERY_TASK_EAGER_PROPAGATES = True

    # When we run beat on development environments, use in-memory transport, so it doesn't
    # try to connect to rabbitmq on localhost (the default behavior).
    CELERY_BROKER_URL = 'memory://'

# Scheduling
CELERY_BEAT_SCHEDULE: Dict[str, Dict[str, Any]]


if IN_DORMANT_MODE:
    CELERY_BEAT_SCHEDULE = {}
else:
    if MARKET == MARKET_B:
        CELERY_TIMEZONE = 'Europe/Stockholm'
    elif MARKET == MARKET_A:
        CELERY_TIMEZONE = 'Europe/Copenhagen'

if strtobool(os.environ.get('RANDOM_CRON_OFFSET', '0')):
    # Randomize cron schedules (for test environments) so they don't all run at exactly the same time
    for task in CELERY_BEAT_SCHEDULE.values():
        import random

        if 'schedule' in task:
            task['schedule'].nowfun = lambda: timezone.now() + timedelta(seconds=random.randint(-300, 300))

# END CELERY SETTINGS

_default_db = dj_database_url.config(conn_max_age=float(os.environ.get("CONN_MAX_AGE", 600)))
_default_db.update({
    # Name the test database after the market the tests are being run on.
    # This is to allow market-specific tests which need a market-specific database to run at the same time.
    'TEST': {'NAME': f'test_{MARKET}'},
})

DATABASES = {
    'default': _default_db,
}

RUNNING_MIGRATIONS = sys.argv[1:2] == ['migrate']
IS_DEV_ENV = strtobool(os.environ.get("IS_DEV_ENV", '0'))

if RUNNING_MIGRATIONS and IS_DEV_ENV and DATABASES['default']['HOST'] not in ('127.0.0.1', 'localhost'):
    print("You are trying to run migrations against a non-local DB! Probably not what you intended...")
    sys.exit(1)

if RUNNING_TESTS:
    USE_TEST_EMAIL_BACKEND = True
else:
    USE_TEST_EMAIL_BACKEND = False


# END mail settings


# TODO: Separate into separate files
# BEGIN Market-specific settings

if RUNNING_TESTS:
    GOOGLE_STREETVIEW_ENABLED = False

# This ensures we only sent one email, even if multiple messages are received in < 5 mins.
# If the user gets one message in minute 2, and one in minute 7, he will get two emails
NOTIFY_NEW_MESSAGE_DELAY = timedelta(minutes=5)

IMPORTER_SHOW_EXCEPTION = strtobool(os.environ.get("IMPORTER_SHOW_EXCEPTION", "0"))
IMPORTER_DISABLE_IMAGE_DOWNLOAD = strtobool(os.environ.get("IMPORTER_DISABLE_IMAGE_DOWNLOAD", "0"))
IMPORTER_USE_LOGDNA = strtobool(os.environ.get("IMPORTER_USE_LOGDNA", "1"))
IMPORTER_LOG_DIFF = strtobool(os.environ.get("IMPORTER_LOG_DIFF", "0"))

if RUNNING_TESTS:
    IMPORTER_USE_LOGDNA = False
    IMPORTER_SHOW_EXCEPTION = True

# DJANGO STUFF

ROOT_URLCONF = 'markets.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'markets.wsgi.application'

ALLOWED_HOSTS = ['*']

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.postgres',
    'django.contrib.staticfiles',
    'django.contrib.sites',
    'django.contrib.redirects',
]


SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'

MARKET_SPECIFIC_APPS = {
    MARKET_B: [
        'market_b_app.apps.MarketBAppConfig',
    ],
    MARKET_A: [
        'market_a_app.apps.MarketAAppConfig',
    ],
}

if MARKET in MARKET_SPECIFIC_APPS:
    # If there is a market-specific app, add it to INSTALLED_APPS
    INSTALLED_APPS += MARKET_SPECIFIC_APPS[MARKET]

if MARKET is None:
    # If making migrations, include all apps so all migrations are generated
    # No market is also used for type checking. If it doesn't include all apps, it will complain
    for market in MARKET_SPECIFIC_APPS:
        INSTALLED_APPS += MARKET_SPECIFIC_APPS[market]


USE_DEVEX = strtobool(os.environ.get("USE_DEVEX", "0"))


STATICFILES_FINDERS = [
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
]

MIDDLEWARE = [
    'django.middleware.gzip.GZipMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.locale.LocaleMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

if RUNNING_TESTS:
    # Don't use Whitenoise middleware when running tests. This speeds tests up immensely
    MIDDLEWARE = list(filter(lambda m: 'whitenoise' not in m, MIDDLEWARE))

DEFAULT_AUTH_BACKEND = 'django.contrib.auth.backends.ModelBackend'

AUTHENTICATION_BACKENDS = [
    DEFAULT_AUTH_BACKEND
]

### Django 3.1.2 exclusives
SECURE_REFERRER_POLICY = None  # type: ignore

if RUNNING_TESTS:
    # Use a fast password hasher when running tests.
    # See https://docs.djangoproject.com/en/2.1/topics/testing/overview/#password-hashing
    PASSWORD_HASHERS = [
        'django.contrib.auth.hashers.MD5PasswordHasher',
    ]

if DISABLE_PASSWORD_CHECKS:
    AUTH_PASSWORD_VALIDATORS = []
else:
    AUTH_PASSWORD_VALIDATORS = [
        {
            'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
            'OPTIONS': {
                'min_length': 8
            }
        },
        {
            'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
        },
    ]

if DEBUG and not RUNNING_TESTS:
    INSTALLED_APPS.append('nplusone.ext.django')
    MIDDLEWARE.append(
        'nplusone.ext.django.NPlusOneMiddleware'
    )
    NPLUSONE_RAISE = strtobool(os.environ.get("NPLUSONE_RAISE", "0"))
    NPLUSONE_WHITELIST = [
        {'label': 'unused_eager_load'},
    ]

ENABLE_DJANGO_DEBUG_TOOLBAR = strtobool(os.environ.get("ENABLE_DJANGO_DEBUG_TOOLBAR", "0"))
if ENABLE_DJANGO_DEBUG_TOOLBAR:
    DEBUG_TOOLBAR_CONFIG = {
        # Always show toolbar, regardless of IP of request (if in DEBUG mode)
        "SHOW_TOOLBAR_CALLBACK": lambda request: DEBUG,
        "SHOW_COLLAPSED": True,
    }
    INSTALLED_APPS.append('debug_toolbar')
    # Debug toolbar must be inserted after gzip middleware, hence and index 1
    MIDDLEWARE.insert(1, 'debug_toolbar.middleware.DebugToolbarMiddleware')


USE_I18N = True
USE_L10N = True
USE_TZ = True

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': ('%(asctime)s [%(process)d] [%(levelname)s] ' +
                       'pathname=%(pathname)s lineno=%(lineno)s ' +
                       'funcname=%(funcName)s %(message)s'),
            'datefmt': '%Y-%m-%d %H:%M:%S'
        },
        'crawling': {
            'format': ('%(asctime)s [%(process)d] [%(levelname)s] ' +
                       'funcname=%(funcName)s %(message)s'),
            'datefmt': '%Y-%m-%d %H:%M:%S'
        },
        'simple': {
            'format': '%(message)s'
        },
        'short': {
            'format': '[%(levelname)s] [%(module)s] line=%(lineno)s %(message)s',
        },
    },
    'handlers': {
        'null': {
            'level': 'DEBUG',
            'class': 'logging.NullHandler',
        },
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose'
        },
        'console-simple': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'boligportal_migrators': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'short'
        },
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'level': os.environ.get('DJANGO_LOG_LEVEL', 'ERROR'),
        },
        **({
               'django.db.backends': {
                   'handlers': ['console-simple'],
                   'level': 'DEBUG',
                   'propagate': False  # type: ignore
               }
           } if strtobool(os.environ.get('LOG_SQL_QUERIES', '0')) else {}),
        'markets': {
            'handlers': ['console'],
            'level': os.environ.get('MARKETS_LOG_LEVEL', 'INFO'),
        },
        'boligportal.migrators': {
            'handlers': ['boligportal_migrators'],
            'level': os.environ.get('MARKETS_LOG_LEVEL', 'INFO'),
        },
        'boligportal': {
            'handlers': ['console'],
            'level': os.environ.get('MARKETS_LOG_LEVEL', 'INFO'),
        },
        'bostadsportal': {
            'handlers': ['console'],
            'level': os.environ.get('MARKETS_LOG_LEVEL', 'INFO'),
        },
        'contracts': {
            'handlers': ['console'],
            'level': os.environ.get('MARKETS_LOG_LEVEL', 'INFO'),
        },
        'dk_contracts': {
            'handlers': ['console'],
            'level': os.environ.get('MARKETS_LOG_LEVEL', 'INFO'),
        },
        'se_contracts': {
            'handlers': ['console'],
            'level': os.environ.get('MARKETS_LOG_LEVEL', 'INFO'),
        },
    }
}

# FIXME Can be removed if https://bugs.webkit.org/show_bug.cgi?id=188165 is solved
CSRF_COOKIE_SAMESITE = None  # type: ignore
# FIXME Can be removed if https://bugs.webkit.org/show_bug.cgi?id=188165 is solved
SESSION_COOKIE_SAMESITE = None  # type: ignore

LOCALE_PATHS = [
    os.path.join(BASE_DIR, "locale")
]

# Whitenoise (static files handling) settings
# Ensure STATIC_ROOT exists.
os.makedirs(STATIC_ROOT, exist_ok=True)


# Enable GZip.
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

if RUNNING_TESTS:
    # When running tests, use the default setting, to avoid having to run collectstatic
    STATICFILES_STORAGE = 'django.contrib.staticfiles.storage.StaticFilesStorage'

SILENCED_SYSTEM_CHECKS = [
    # Suppress warning: Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.
    'fields.W342',
    # Allow index names >30 characters, because we aren't using Oracle
    'models.E034',
]
# rethrow errors thrown in signal receivers when running unit tests, otherwise they are not visible
THROW_ERRORS_FROM_SIGNALS = RUNNING_TESTS
